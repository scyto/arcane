import type { VulnerabilityScanSummary } from '$lib/types/vulnerability.type';

const SCAN_IN_PROGRESS_STATUSES = new Set(['pending', 'scanning']);

export type VulnerabilityScanPollOptions = {
	intervalMs?: number;
	maxAttempts?: number;
	onUpdate?: (summary: VulnerabilityScanSummary) => void;
	onComplete?: (summary: VulnerabilityScanSummary) => void;
	onError?: (error: unknown) => void;
};

export type VulnerabilityScanTracker = {
	cancel: () => void;
	promise: Promise<VulnerabilityScanSummary>;
};

export type VulnerabilityScanStabilizeOptions = {
	scanRequestedAt?: string | number | Date | null;
	failedRecheckDelayMs?: number;
	maxFailedRechecks?: number;
	staleFailureGraceMs?: number;
};

function delay(ms: number): Promise<void> {
	return new Promise((resolve) => {
		setTimeout(resolve, ms);
	});
}

export function toTimestampMs(value?: string | number | Date | null): number {
	if (value == null) return 0;
	if (value instanceof Date) {
		const ts = value.getTime();
		return Number.isFinite(ts) ? ts : 0;
	}
	if (typeof value === 'number') {
		return Number.isFinite(value) ? value : 0;
	}
	const ts = Date.parse(value);
	return Number.isFinite(ts) ? ts : 0;
}

export function isVulnerabilityScanInProgress(status?: string | null): boolean {
	if (!status) return false;
	return SCAN_IN_PROGRESS_STATUSES.has(status);
}

export function isLikelyStaleFailedSummary(
	summary: VulnerabilityScanSummary,
	scanRequestedAt?: string | number | Date | null,
	staleFailureGraceMs = 1500
): boolean {
	if (summary.status !== 'failed') return false;

	const requestedAtMs = toTimestampMs(scanRequestedAt);
	if (requestedAtMs <= 0) return false;

	const summaryTimeMs = toTimestampMs(summary.scanTime);
	const scanTimeLooksOld = summaryTimeMs <= 0 || summaryTimeMs + staleFailureGraceMs < requestedAtMs;
	const missingErrorDetails = !summary.error || summary.error.trim() === '';

	return scanTimeLooksOld || missingErrorDetails;
}

export async function stabilizeFailedVulnerabilitySummary(
	imageId: string,
	initialSummary: VulnerabilityScanSummary,
	fetchSummary: (imageId: string) => Promise<VulnerabilityScanSummary>,
	options: VulnerabilityScanStabilizeOptions = {}
): Promise<VulnerabilityScanSummary> {
	const { scanRequestedAt, failedRecheckDelayMs = 1000, maxFailedRechecks = 2, staleFailureGraceMs = 1500 } = options;

	let summary = initialSummary;
	if (!isLikelyStaleFailedSummary(summary, scanRequestedAt, staleFailureGraceMs)) {
		return summary;
	}

	const retries = Math.max(0, maxFailedRechecks);
	for (let attempt = 0; attempt < retries; attempt++) {
		await delay(failedRecheckDelayMs);
		summary = await fetchSummary(imageId);
		if (summary.status !== 'failed') {
			return summary;
		}
	}

	return summary;
}

export function startVulnerabilityScanPolling(
	imageId: string,
	fetchSummary: (imageId: string) => Promise<VulnerabilityScanSummary>,
	options: VulnerabilityScanPollOptions = {}
): () => void {
	const { intervalMs = 2000, maxAttempts = 0, onUpdate, onComplete, onError } = options;
	let attempts = 0;
	let cancelled = false;
	let timeoutId: ReturnType<typeof setTimeout> | null = null;

	const schedule = () => {
		if (cancelled) return;
		timeoutId = setTimeout(run, intervalMs);
	};

	const run = async () => {
		if (cancelled) return;
		attempts += 1;
		try {
			const summary = await fetchSummary(imageId);
			onUpdate?.(summary);

			const isScanning = isVulnerabilityScanInProgress(summary?.status);
			if (!isScanning) {
				onComplete?.(summary);
				return;
			}
		} catch (error) {
			onError?.(error);
		}

		if (maxAttempts > 0 && attempts >= maxAttempts) {
			onError?.(new Error('Scan polling exceeded max attempts.'));
			return;
		}

		schedule();
	};

	void run();

	return () => {
		cancelled = true;
		if (timeoutId) {
			clearTimeout(timeoutId);
		}
	};
}

export function startVulnerabilityScanTracking(
	imageId: string,
	fetchSummary: (imageId: string) => Promise<VulnerabilityScanSummary>,
	options: VulnerabilityScanPollOptions = {}
): VulnerabilityScanTracker {
	let resolvePromise: (summary: VulnerabilityScanSummary) => void;
	let rejectPromise: (error: unknown) => void;

	const promise = new Promise<VulnerabilityScanSummary>((resolve, reject) => {
		resolvePromise = resolve;
		rejectPromise = reject;
	});

	const cancel = startVulnerabilityScanPolling(imageId, fetchSummary, {
		...options,
		onComplete: (summary) => {
			options.onComplete?.(summary);
			if (summary.status === 'completed') {
				resolvePromise(summary);
			} else {
				rejectPromise(summary);
			}
		},
		onError: (error) => {
			options.onError?.(error);
			rejectPromise(error);
		}
	});

	return { cancel, promise };
}
