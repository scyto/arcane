package services

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net"
	"os"
	"strings"
	"testing"
	"time"

	containertypes "github.com/docker/docker/api/types/container"
	mounttypes "github.com/docker/docker/api/types/mount"
	"github.com/getarcaneapp/arcane/backend/internal/models"
	"github.com/getarcaneapp/arcane/backend/internal/utils/timeouts"
	"github.com/getarcaneapp/arcane/types/vulnerability"
	"github.com/stretchr/testify/require"
)

func TestIsExpectedDockerStreamEndErrorInternal(t *testing.T) {
	tests := []struct {
		name string
		err  error
		want bool
	}{
		{name: "nil", err: nil, want: false},
		{name: "eof", err: io.EOF, want: true},
		{name: "wrapped eof", err: fmt.Errorf("wrapped: %w", io.EOF), want: true},
		{name: "net err closed", err: net.ErrClosed, want: true},
		{name: "closed network connection", err: errors.New("read tcp 127.0.0.1:1234->127.0.0.1:5678: use of closed network connection"), want: true},
		{name: "broken pipe", err: errors.New("write: broken pipe"), want: true},
		{name: "connection reset by peer", err: errors.New("read: connection reset by peer"), want: true},
		{name: "unexpected", err: errors.New("some other error"), want: false},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			require.Equal(t, tt.want, isExpectedDockerStreamEndErrorInternal(tt.err))
		})
	}
}

func TestDecodeTrivyReportFromFileInternal_LargePayload(t *testing.T) {
	tmpFile, err := os.CreateTemp("", "trivy-report-*.json")
	require.NoError(t, err)
	defer func() {
		require.NoError(t, os.Remove(tmpFile.Name()))
	}()
	defer func() {
		require.NoError(t, tmpFile.Close())
	}()

	const vulnCount = 4000
	vulns := make([]vulnerability.TrivyVulnerability, 0, vulnCount)
	for i := range vulnCount {
		vulns = append(vulns, vulnerability.TrivyVulnerability{
			VulnerabilityID:  fmt.Sprintf("CVE-2026-%04d", i),
			PkgName:          fmt.Sprintf("pkg-%d", i),
			InstalledVersion: "1.0.0",
			FixedVersion:     "1.0.1",
			Severity:         "HIGH",
		})
	}

	report := vulnerability.TrivyReport{
		SchemaVersion: 2,
		ArtifactName:  "example/image:latest",
		ArtifactType:  "container_image",
		Results: []vulnerability.TrivyResults{
			{
				Target:          "alpine:3.20",
				Class:           "os-pkgs",
				Type:            "alpine",
				Vulnerabilities: vulns,
			},
		},
	}

	encoder := json.NewEncoder(tmpFile)
	require.NoError(t, encoder.Encode(report))

	decoded, err := decodeTrivyReportFromFileInternal(tmpFile)
	require.NoError(t, err)
	require.NotNil(t, decoded)
	require.Equal(t, report.ArtifactName, decoded.ArtifactName)
	require.Len(t, decoded.Results, 1)
	require.Len(t, decoded.Results[0].Vulnerabilities, vulnCount)
}

func TestDecodeTrivyReportFromFileInternal_RecoversFromPrefixedAndTrailingNoise(t *testing.T) {
	tmpFile, err := os.CreateTemp("", "trivy-report-noisy-*.json")
	require.NoError(t, err)
	defer func() {
		require.NoError(t, os.Remove(tmpFile.Name()))
	}()
	defer func() {
		require.NoError(t, tmpFile.Close())
	}()

	report := vulnerability.TrivyReport{
		SchemaVersion: 2,
		ArtifactName:  "ghcr.io/getarcaneapp/example:latest",
		ArtifactType:  "container_image",
		Results: []vulnerability.TrivyResults{
			{Target: "alpine:3.20", Class: "os-pkgs", Type: "alpine"},
		},
	}

	reportBytes, err := json.Marshal(report)
	require.NoError(t, err)

	_, err = tmpFile.WriteString("WARN scanner warming cache\n")
	require.NoError(t, err)
	_, err = tmpFile.Write(reportBytes)
	require.NoError(t, err)
	_, err = tmpFile.WriteString("\nINFO scan completed\n")
	require.NoError(t, err)

	decoded, err := decodeTrivyReportFromFileInternal(tmpFile)
	require.NoError(t, err)
	require.NotNil(t, decoded)
	require.Equal(t, report.ArtifactName, decoded.ArtifactName)
	require.Equal(t, report.SchemaVersion, decoded.SchemaVersion)
}

func TestDecodeTrivyReportFromFileInternal_SelectsReportFromMultipleJSONObjects(t *testing.T) {
	tmpFile, err := os.CreateTemp("", "trivy-report-multi-json-*.json")
	require.NoError(t, err)
	defer func() {
		require.NoError(t, os.Remove(tmpFile.Name()))
	}()
	defer func() {
		require.NoError(t, tmpFile.Close())
	}()

	report := vulnerability.TrivyReport{
		SchemaVersion: 2,
		ArtifactName:  "ghcr.io/getarcaneapp/example:stable",
		ArtifactType:  "container_image",
		Results: []vulnerability.TrivyResults{
			{Target: "debian:12", Class: "os-pkgs", Type: "debian"},
		},
	}

	reportBytes, err := json.Marshal(report)
	require.NoError(t, err)

	_, err = tmpFile.WriteString(`{"action":"vulnerability_scan","success":false}` + "\n")
	require.NoError(t, err)
	_, err = tmpFile.Write(reportBytes)
	require.NoError(t, err)

	decoded, err := decodeTrivyReportFromFileInternal(tmpFile)
	require.NoError(t, err)
	require.NotNil(t, decoded)
	require.Equal(t, report.ArtifactName, decoded.ArtifactName)
	require.Equal(t, report.SchemaVersion, decoded.SchemaVersion)
}

func TestDecodeTrivyReportFromFileInternal_HandlesConcatenatedJSONObjects(t *testing.T) {
	tmpFile, err := os.CreateTemp("", "trivy-report-concatenated-*.json")
	require.NoError(t, err)
	defer func() {
		require.NoError(t, os.Remove(tmpFile.Name()))
	}()
	defer func() {
		require.NoError(t, tmpFile.Close())
	}()

	report := vulnerability.TrivyReport{
		SchemaVersion: 2,
		ArtifactName:  "ghcr.io/getarcaneapp/example:concat",
		ArtifactType:  "container_image",
		Results: []vulnerability.TrivyResults{
			{Target: "ubuntu:24.04", Class: "os-pkgs", Type: "ubuntu"},
		},
	}

	reportBytes, err := json.Marshal(report)
	require.NoError(t, err)

	_, err = tmpFile.Write(reportBytes)
	require.NoError(t, err)
	_, err = tmpFile.WriteString(`{"message":"done"}`)
	require.NoError(t, err)

	decoded, err := decodeTrivyReportFromFileInternal(tmpFile)
	require.NoError(t, err)
	require.NotNil(t, decoded)
	require.Equal(t, report.ArtifactName, decoded.ArtifactName)
	require.Equal(t, report.SchemaVersion, decoded.SchemaVersion)
}

func TestCleanupTrivyLogTempFilesInternal_RemovesFiles(t *testing.T) {
	stdoutFile, err := os.CreateTemp("", "trivy-stdout-test-*")
	require.NoError(t, err)
	stderrFile, err := os.CreateTemp("", "trivy-stderr-test-*")
	require.NoError(t, err)

	stdoutPath := stdoutFile.Name()
	stderrPath := stderrFile.Name()

	_, err = stdoutFile.WriteString("stdout")
	require.NoError(t, err)
	_, err = stderrFile.WriteString("stderr")
	require.NoError(t, err)

	cleanupTrivyLogTempFilesInternal(context.Background(), stdoutFile, stderrFile)

	_, err = os.Stat(stdoutPath)
	require.Error(t, err)
	require.True(t, os.IsNotExist(err))

	_, err = os.Stat(stderrPath)
	require.Error(t, err)
	require.True(t, os.IsNotExist(err))
}

func TestBuildTrivyContainerResourcesInternal_Defaults(t *testing.T) {
	resources, applyLimits := buildTrivyContainerResourcesInternal(nil)

	require.True(t, applyLimits)
	require.Equal(t, int64(1_000_000_000), resources.NanoCPUs)
	require.Equal(t, int64(0), resources.Memory)
	require.Equal(t, int64(0), resources.MemorySwap)
}

func TestBuildTrivyContainerResourcesInternal_LimitsDisabled(t *testing.T) {
	cfg := &models.Settings{
		TrivyResourceLimitsEnabled: models.SettingVariable{Value: "false"},
		TrivyCpuLimit:              models.SettingVariable{Value: "2"},
		TrivyMemoryLimitMb:         models.SettingVariable{Value: "2048"},
	}

	resources, applyLimits := buildTrivyContainerResourcesInternal(cfg)

	require.False(t, applyLimits)
	require.Equal(t, int64(0), resources.NanoCPUs)
	require.Equal(t, int64(0), resources.Memory)
	require.Equal(t, int64(0), resources.MemorySwap)
}

func TestBuildTrivyContainerResourcesInternal_CustomLimits(t *testing.T) {
	cfg := &models.Settings{
		TrivyResourceLimitsEnabled: models.SettingVariable{Value: "true"},
		TrivyCpuLimit:              models.SettingVariable{Value: "2.5"},
		TrivyMemoryLimitMb:         models.SettingVariable{Value: "2048"},
	}

	resources, applyLimits := buildTrivyContainerResourcesInternal(cfg)

	require.True(t, applyLimits)
	require.Equal(t, int64(2_500_000_000), resources.NanoCPUs)
	require.Equal(t, int64(2_147_483_648), resources.Memory)
	require.Equal(t, int64(2_147_483_648), resources.MemorySwap)
}

func TestBuildTrivyCommandArgs_WithCacheDir(t *testing.T) {
	svc := &VulnerabilityService{}
	outputPath := "/tmp/trivy-result-test.json"

	cmdArgs, tempFiles := svc.buildTrivyCommandArgs(context.Background(), "alpine:3.20", "", "", "/tmp/trivy-cache", outputPath)

	require.Empty(t, tempFiles)
	require.Contains(t, cmdArgs, "--cache-dir")
	require.Contains(t, cmdArgs, "/tmp/trivy-cache")
	require.Contains(t, cmdArgs, "--output")
	require.Contains(t, cmdArgs, outputPath)
	require.Equal(t, "alpine:3.20", cmdArgs[len(cmdArgs)-1])
}

func TestBuildTrivyCommandArgs_WithoutCacheDir(t *testing.T) {
	svc := &VulnerabilityService{}
	outputPath := "/tmp/trivy-result-test.json"

	cmdArgs, tempFiles := svc.buildTrivyCommandArgs(context.Background(), "alpine:3.20", "", "", "", outputPath)

	require.Empty(t, tempFiles)
	require.NotContains(t, cmdArgs, "--cache-dir")
	require.Contains(t, cmdArgs, "--output")
	require.Contains(t, cmdArgs, outputPath)
	require.Equal(t, "alpine:3.20", cmdArgs[len(cmdArgs)-1])
}

func TestBuildTrivyHostConfig_ExcludesResourcesWhenLimitsDisabled(t *testing.T) {
	resources := containertypes.Resources{
		NanoCPUs:   int64(2_000_000_000),
		Memory:     int64(1_073_741_824),
		MemorySwap: int64(1_073_741_824),
	}

	hostConfig := buildTrivyHostConfig("cache-volume", nil, resources, "", false)
	require.Equal(t, int64(0), hostConfig.Resources.NanoCPUs)
	require.Equal(t, int64(0), hostConfig.Resources.Memory)
	require.Equal(t, int64(0), hostConfig.Resources.MemorySwap)
}

func TestBuildTrivyHostConfig_IncludesResourcesWhenLimitsEnabled(t *testing.T) {
	resources := containertypes.Resources{
		NanoCPUs:   int64(2_000_000_000),
		Memory:     int64(1_073_741_824),
		MemorySwap: int64(1_073_741_824),
	}

	hostConfig := buildTrivyHostConfig("cache-volume", nil, resources, "", true)
	require.Equal(t, resources.NanoCPUs, hostConfig.Resources.NanoCPUs)
	require.Equal(t, resources.Memory, hostConfig.Resources.Memory)
	require.Equal(t, resources.MemorySwap, hostConfig.Resources.MemorySwap)
}

func TestBuildTrivyHostConfig_UsesCPUSetAndClearsNanoCPUs(t *testing.T) {
	resources := containertypes.Resources{
		NanoCPUs:   int64(2_000_000_000),
		Memory:     int64(1_073_741_824),
		MemorySwap: int64(1_073_741_824),
	}

	hostConfig := buildTrivyHostConfig("cache-volume", nil, resources, "0-1", true)
	require.Equal(t, int64(0), hostConfig.Resources.NanoCPUs)
	require.Equal(t, "0-1", hostConfig.Resources.CpusetCpus)
	require.Equal(t, resources.Memory, hostConfig.Resources.Memory)
	require.Equal(t, resources.MemorySwap, hostConfig.Resources.MemorySwap)
}

func TestIsSynologyDockerHostInternal(t *testing.T) {
	// DS220+ (Kernel 4.x): single-line
	require.True(t, isSynologyDockerHostInternal("Synology NAS"))
	// DS925+ (Kernel 5.x): OS field contains a newline before "(containerized)"
	require.True(t, isSynologyDockerHostInternal("Synology NAS\n (containerized)"))
	// Variation: Windows-style line ending
	require.True(t, isSynologyDockerHostInternal("Synology NAS\r\n (containerized)"))
	// Case-insensitive
	require.True(t, isSynologyDockerHostInternal("synology nas"))
	// Padded with spaces
	require.True(t, isSynologyDockerHostInternal("  Synology NAS  "))
	// Empty / non-Synology
	require.False(t, isSynologyDockerHostInternal(""))
	require.False(t, isSynologyDockerHostInternal("Ubuntu 24.04.1 LTS"))
	require.False(t, isSynologyDockerHostInternal("Ubuntu 24.04.1 LTS\n (containerized)"))
}

func TestBuildTrivyCPUSetInternal(t *testing.T) {
	require.Equal(t, "", buildTrivyCPUSetInternal(0, 4))
	require.Equal(t, "0", buildTrivyCPUSetInternal(1_000_000_000, 4))
	require.Equal(t, "0-1", buildTrivyCPUSetInternal(2_500_000_000, 4))
	require.Equal(t, "0-1", buildTrivyCPUSetInternal(3_000_000_000, 2))
	require.Equal(t, "0", buildTrivyCPUSetInternal(1_000_000_000, 0))
}

func TestGetTrivySingleScanCacheDirForSlotInternal(t *testing.T) {
	svc := &VulnerabilityService{}

	require.Equal(t, "/root/.cache/arcane-scan-slots/slot-0", svc.getTrivySingleScanCacheDirForSlotInternal(0))
	require.Equal(t, "/root/.cache/arcane-scan-slots/slot-2", svc.getTrivySingleScanCacheDirForSlotInternal(2))
	// Negative slot IDs should normalize to slot-0
	require.Equal(t, "/root/.cache/arcane-scan-slots/slot-0", svc.getTrivySingleScanCacheDirForSlotInternal(-1))
}

func TestGetTrivyScanSlotChannelInternal_PrefillsSlots(t *testing.T) {
	svc := &VulnerabilityService{}

	slotCh := svc.getTrivyScanSlotChannelInternal(3)
	require.NotNil(t, slotCh)
	require.Equal(t, 3, cap(slotCh))
	require.Equal(t, 3, len(slotCh))

	seen := map[int]bool{}
	for i := 0; i < 3; i++ {
		slotID := <-slotCh
		seen[slotID] = true
	}

	require.True(t, seen[0])
	require.True(t, seen[1])
	require.True(t, seen[2])
	require.Equal(t, 0, len(slotCh))
}

func TestTrivyMountSummariesInternal(t *testing.T) {
	require.Nil(t, trivyMountSummariesInternal(nil))

	hostConfig := &containertypes.HostConfig{
		Mounts: []mounttypes.Mount{
			{
				Type:   mounttypes.TypeBind,
				Source: "/var/run/docker.sock",
				Target: "/var/run/docker.sock",
			},
			{
				Type:   mounttypes.TypeVolume,
				Source: "arcane-trivy-cache",
				Target: "/root/.cache",
			},
			{
				Type:   mounttypes.TypeTmpfs,
				Target: "/tmp",
			},
		},
	}

	require.Equal(t,
		[]string{
			"/var/run/docker.sock:/var/run/docker.sock",
			"arcane-trivy-cache:/root/.cache",
			"tmpfs:/tmp",
		},
		trivyMountSummariesInternal(hostConfig),
	)
}

func TestTruncateTrivyLogOutputInternal(t *testing.T) {
	require.Equal(t, "", truncateTrivyLogOutputInternal("", 32))
	require.Equal(t, "keep me", truncateTrivyLogOutputInternal("  keep me  ", 32))

	longOutput := strings.Repeat("x", 80)
	truncated := truncateTrivyLogOutputInternal(longOutput, 16)
	require.Equal(t, strings.Repeat("x", 16)+" ...<truncated>", truncated)
}

func TestTrivyContainerWaitTimeoutInternal(t *testing.T) {
	require.Equal(t, timeouts.DefaultTrivyScan+timeouts.DefaultDockerAPI, trivyContainerWaitTimeoutInternal(""))
	require.Equal(t, 5*time.Minute+timeouts.DefaultDockerAPI, trivyContainerWaitTimeoutInternal("5m"))
	require.Equal(t, timeouts.DefaultTrivyScan+timeouts.DefaultDockerAPI, trivyContainerWaitTimeoutInternal("not-a-duration"))
	require.Equal(t, timeouts.DefaultTrivyScan+timeouts.DefaultDockerAPI, trivyContainerWaitTimeoutInternal("0s"))
}

func TestAwaitContainerWaitResponseInternal_Status(t *testing.T) {
	statusCh := make(chan containertypes.WaitResponse, 1)
	errCh := make(chan error)
	statusCh <- containertypes.WaitResponse{StatusCode: 12}

	status, err := awaitContainerWaitResponseInternal(context.Background(), statusCh, errCh)
	require.NoError(t, err)
	require.Equal(t, int64(12), status)
}

func TestAwaitContainerWaitResponseInternal_Error(t *testing.T) {
	statusCh := make(chan containertypes.WaitResponse)
	errCh := make(chan error, 1)
	errCh <- errors.New("boom")

	status, err := awaitContainerWaitResponseInternal(context.Background(), statusCh, errCh)
	require.Error(t, err)
	require.Contains(t, err.Error(), "boom")
	require.Equal(t, int64(0), status)
}

func TestAwaitContainerWaitResponseInternal_ClosedErrorChannelStillReadsStatus(t *testing.T) {
	statusCh := make(chan containertypes.WaitResponse, 1)
	errCh := make(chan error)

	close(errCh)
	statusCh <- containertypes.WaitResponse{StatusCode: 7}

	status, err := awaitContainerWaitResponseInternal(context.Background(), statusCh, errCh)
	require.NoError(t, err)
	require.Equal(t, int64(7), status)
}

func TestAwaitContainerWaitResponseInternal_ContextDone(t *testing.T) {
	statusCh := make(chan containertypes.WaitResponse)
	errCh := make(chan error)
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Millisecond)
	defer cancel()

	status, err := awaitContainerWaitResponseInternal(ctx, statusCh, errCh)
	require.Error(t, err)
	require.ErrorIs(t, err, context.DeadlineExceeded)
	require.Equal(t, int64(0), status)
}

func TestAwaitContainerWaitResponseInternal_NoStatus(t *testing.T) {
	statusCh := make(chan containertypes.WaitResponse)
	errCh := make(chan error)
	close(statusCh)
	close(errCh)

	status, err := awaitContainerWaitResponseInternal(context.Background(), statusCh, errCh)
	require.Error(t, err)
	require.Contains(t, err.Error(), "ended without status")
	require.Equal(t, int64(0), status)
}
